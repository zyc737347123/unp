# TCP/UDP/IP学习笔记

##TCP

###0.1 TCP的三次握手

所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 `connect()` 时。将触发三次握手。

- 服务器端套接字（socket）经过socket，bind，listen三个函数调用，处于`LISTEN`状态

- 第一次握手(SYN=1, seq=x):

  客户端调用connect（堵塞）

  客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。

  发送完毕后，客户端进入 `SYN_SEND` 状态。

- 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

  服务器调用accept（堵塞）

  服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 `SYN_RCVD` 状态。

  收到这个从服务器ACK，客户端connect调用返回，客户端此时状态已经进入`ESTABLISHED`

- 第三次握手(ACK=1，ACKnum=y+1)

  服务器accept调用返回（实际不一定，如果没有调用accept，连接就会在accept queue里，等待出队）

  客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1
  
  发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED`状态，TCP 握手结束。

TCP的三次握手图示：
![](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)

1. **在三次握手的时候，SYN（同步分节）可以带上什么信息？**

   首先SYN会告知对端本端选择的Sequence Number的初始值，Sequence Number用于在TCP连接中进行数据包的排序和确认等等作用，**Sequence Number**是包的序号，**用来解决网络包乱序（reordering）问题**，每次建立TCP连接，每端都出随机初始化本端的Sequence Number，并使用SYN告知对端；

   同时每一个SYN都可以含有多个TCP选项：

   - MSS选项：本端用于告知对端，本端可接受的最大分节大小（max segment size）
   - 窗口规模选项：TCP报文头的窗口只有16bit，所以滑动窗口的最大窗口大小为65535；这个选项用于指定TCP报文头中的窗口大小左移位数，用于扩大窗口大小，最大可达1GB（65535 * 2^14）
   - 时间戳选项：防止由于失而复得的分组可能造成的数据损毁

2. **如果机器上出现很多SYN_SEND状态的连接？**

   如果出现很多SYN_SEND，那一般有这么几种情况：

   - 是你要访问的网站不存在或线路不好
   - 是用扫描软件扫描一个网段的机器，也会出出现很多SYN_SENT，另外就是可能中了病毒了，例如中了"冲击波"，病毒发作时会扫描其它机器，这样会有很多SYN_SENT出现

3. **如果机器上出现很多SYN_RCVD状态的连接？**

   正常情况下SYN_RCVD状态非常短暂。如果发现有很多SYN_RCVD状态，那你的机器有可能被**SYN Flood**的DoS(拒绝服务攻击)攻击了

   在进行三次握手时，攻击软件向被攻击的服务器发送SYN连接请求(握手的第一步)，但是这个地址是伪造的，如攻击软件随机伪造了51.133.163.104、65.158.99.152等等地址。 服务器 在收到连接请求时将标志位 ACK和 SYN 置1发送给客户端(握手的第二步)，但是这些客户端的IP地址都是伪造的，服务器根本找不到客户机，也就是说握手的第三步不可能完成
   
   这种情况下服务器端一般会重试(再次发送SYN+ACK给客户端)并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为**SYN Timeout**，一般来说这个时间是分钟的数量级(大约为30秒-2分钟);一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源，比如数以万计的半连接，即使是简单的保存并遍历也会消耗非常多的 CPU 时间和内存，何况还要不断对这个列表中的IP进行SYN+ACK的重试。此时从正常客户的角度看来，服务器失去响应，这种情况我们称做： 服务器端受到了**SYN Flood攻击(SYN洪水攻击 )**

4. **什么是BACKLOG？**

   backlog其实是一个连接队列，在Linux内核2.2之前，backlog大小包括半连接状态和全连接状态两种队列大小；在Linux内核2.2之后，分离为两个backlog来分别限制半连接（SYN_RCVD状态）队列大小和全连接（ESTABLISHED状态）队列大小：
   ![](https://images2015.cnblogs.com/blog/927655/201612/927655-20161215133843776-605308204.png)

5. **客户端connect()返回代表TCP连接建立成功吗？**

   有可能此时accept queue 已满，系统会直接丢弃后续ACK请求；客户端误以为连接已建立，开始调用等待至超时；服务器则等待ACK超时，会重传SYN+ACK 给客户端，重传次数受限 net.ipv4.tcp_synack_retries ，默认为5，表示重发5次，每次等待30~40秒，即半连接默认时间大约为180秒，该参数可以在tcp被洪水攻击是临时启用这个参数

6. **BACKLOG设置过大可能会导致什么问题？**

   此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在[队列](http://jaseywang.me/2014/07/20/tcp-queue-的一些问题/)里就被对方关闭了

7. **为什么需要三次握手？**

   **为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接”，主要目的防止server端一直等待，浪费资源

   基于通信方式和双全工的特性，所以在tcp连接建立时,client需要将自己的ISN序号告知对方，同时需要对方的确定,server也需要将自己的ISN序号告知对方，同时也要对方的确定,server将自己的ack和发出的syn标志的告知对方ISN的合并在一次传递中，这样子节省流量。所以三次握手很合理

### 0.2 TCP的四次挥手

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 `close()` 操作即可产生挥手操作

- 第一次挥手(FIN=1，seq=x)

  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

  发送完毕后，客户端进入 `FIN_WAIT_1` 状态。

- 第二次挥手(ACK=1，ACKnum=x+1)

  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。**此时read()或recv()会返回0**

  发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。

- 第三次挥手(FIN=1，seq=y)

  服务器端准备好关闭连接时（服务器调用close或shutdown），向客户端发送结束连接请求，FIN 置为1。

  发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。

- 第四次挥手(ACK=1，ACKnum=y+1)

  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。

  服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。

  客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。

四次挥手的示意图如下：
![](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png)

1. **如果机器出现大量连接处于CLOSE_WAIT怎样分析？**

   [close wait浅析](https://blog.huoding.com/2016/01/19/488)
   [close wait实例分析](https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&mid=402163560&idx=1&sn=5269044286ce1d142cca1b5fed3efab1&3rd=MzA3MDU4NTYzMw==&scene=6#rd)

2. **如果本端处于FIN_WAIT_2，但对端不发送FIN，会怎样？**

   Linux下当一个socket不再被任何应用引用时，它便成为了一个孤儿，而 tcp_fin_timeout 限定了成为孤儿的 FIN_WAIT2 所能存活的时间，实际上此时间是「net.ipv4.tcp_fin_timeout」控制的，不过在测试中发现，FIN_WAIT2 存在的时间并不是精确的等于 tcp_fin_timeout 的设置，存在一定的偏差。此外，需要说明的是在 tcp_fin_timeout 后，FIN_WAIT2 并没有迁移到 TIME_WAIT，而是直接关闭了

   如果是用shutdown关闭本端，此时FIN_WAIT2就不会成为孤儿，就不会受 tcp_fin_timeout限制，FIN_WAIT2 会一直存在，直到本端 close 连接或者退出

3. **如果本端处于LAST_ACK，但对端不发送ACK，会怎样？**

   `LAST_ACK` 状态也有超时机制，最后还是会到CLOSE状态

4. **为什么需要四次挥手？**

   TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化

   总的来说，需要正常结束结束双工通道就需要四次，两端在结束本端的发送工作都行一对FIN和ACK，所以是四次