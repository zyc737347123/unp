# TCP/UDP/IP学习笔记

## TCP概览

### 0.1 TCP的三次握手

所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 `connect()` 时。将触发三次握手。

- 服务器端套接字（socket）经过socket，bind，listen三个函数调用，处于`LISTEN`状态

- 第一次握手(SYN=1, seq=x):

  **客户端调用connect（堵塞）**

  客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号(ISN) X,保存在包头的序列号(Sequence Number)字段里。

  发送完毕后，客户端进入 `SYN_SEND` 状态。

- 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

  **服务器调用accept（堵塞）**

  服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 `SYN_RCVD` 状态。

  收到这个服务器ACK，**客户端connect调用返回**，客户端此时状态已经进入`ESTABLISHED`

- 第三次握手(ACK=1，ACKnum=y+1)

  **服务器的accept调用返回（如果没有调用accept，连接就会在accept queue里，等待出队）**

  客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1
  
  发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED`状态，TCP 握手结束。

TCP的三次握手图示：
![](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)

1. **在三次握手的时候，SYN（同步分节）可以带上什么信息？**

   首先SYN会告知对端本端选择的Sequence Number的初始值，Sequence Number用于在TCP连接中进行数据包的排序和确认等等作用，**Sequence Number**是包的序号，**用来解决网络包乱序（reordering）问题**，每次建立TCP连接，每端都出随机初始化本端的Sequence Number，并使用SYN告知对端；

   同时每一个SYN都可以含有多个**TCP选项**：

   - MSS选项：本端用于告知对端，本端可接受的最大分节大小（max segment size）
   - 窗口规模选项：TCP报文头的窗口只有16bit，所以滑动窗口的最大窗口大小为65535；这个选项用于指定TCP报文头中的窗口大小左移位数，用于扩大窗口大小，最大可达1GB（65535 * 2^14）
   - 时间戳选项：防止由于失而复得的分组可能造成的数据损毁

2. **如果机器上出现很多SYN_SEND状态的连接？**

   如果出现很多SYN_SEND，那一般有这么几种情况：

   - 你要访问的网站不存在或线路不好
   - 主动用扫描软件扫描一个网段上的其他机器，也会出现很多SYN_SENT，另外就是可能中了病毒了，例如中了"冲击波"，病毒发作时会扫描其它机器，这样会有很多SYN_SENT出现

3. **如果机器上出现很多SYN_RCVD状态的连接？**

   正常情况下SYN_RCVD状态非常短暂。如果发现有很多SYN_RCVD状态，那你的机器有可能被**SYN Flood**的DoS(拒绝服务攻击)攻击了

   在进行三次握手时，攻击软件向被攻击的服务器发送SYN连接请求(握手的第一步)，但是这个地址是伪造的，如攻击软件随机伪造了51.133.163.104、65.158.99.152等等地址。 服务器 在收到连接请求时将标志位 ACK和 SYN 置1发送给客户端(握手的第二步)，但是这些客户端的IP地址都是伪造的，服务器根本找不到客户机，也就是说握手的第三步不可能完成
   
   这种情况下服务器端一般会重试(再次发送SYN+ACK给客户端)并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为**SYN Timeout**，一般来说这个时间是分钟的数量级(**大约为30秒-2分钟)**;一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的**半连接列表**而消耗非常多的资源，比如数以万计的半连接，即使是简单的保存并遍历也会消耗非常多的 CPU 时间和内存，何况还要不断对这个列表中的IP进行SYN+ACK的重试。此时从正常客户的角度看来，服务器失去响应，这种情况我们称做： 服务器端受到了**SYN Flood攻击(SYN洪水攻击 )**

4. **什么是BACKLOG？**

   backlog其实是一个连接队列，在Linux内核2.2之前，backlog大小包括半连接状态和全连接状态两种队列大小；在Linux内核2.2之后，分离为两个backlog来分别限制半连接（SYN_RCVD状态）队列大小和全连接（ESTABLISHED状态）队列大小：
   ![](https://images2015.cnblogs.com/blog/927655/201612/927655-20161215133843776-605308204.png)

5. **客户端connect()返回代表TCP连接建立成功吗？**

   有可能此时服务端accept queue 已满，服务端的OS会直接丢弃后续ACK请求；客户端误以为连接已建立，开始调用(send/recv)等待至超时；服务器则等待ACK超时，会重传SYN+ACK 给客户端，重传次数受限 net.ipv4.tcp_synack_retries ，默认为5，表示重发5次，每次等待30~40秒，即半连接默认时间大约为180秒，可以在tcp被洪水攻击临时修改这个参数，遭受syn-flood攻击时改为1或2

6. **BACKLOG设置过大可能会导致什么问题？**

   此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在[队列](http://jaseywang.me/2014/07/20/tcp-queue-的一些问题/)里就被对方因请求(send/recv)超时关闭了

7. **为什么需要三次握手？**

   **为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接”，主要目的防止server端一直等待，浪费资源

   基于通信方式和双全工的特性，所以在tcp连接建立时,client需要将自己的ISN序号告知对方，同时需要对方的确定(ACK),server也需要将自己的ISN序号告知对方，同时也要对方的确定(ACK),server将自己的ack和发出的syn标志的告知对方ISN的合并在一次传递中，这样节省流量,所以三次握手很合理。

### 0.2 TCP的四次挥手

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 `close()` 操作即可产生挥手操作

- 第一次挥手(FIN=1，seq=x)

  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

  发送完毕后，客户端进入 `FIN_WAIT_1` 状态。

- 第二次挥手(ACK=1，ACKnum=x+1)

  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但服务端还没有准备好关闭连接。**此时read()或recv()会返回0**

  发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。

- 第三次挥手(FIN=1，seq=y)

  服务器端准备好关闭连接时（服务器调用close或shutdown），向客户端发送结束连接请求，FIN 置为1。

  发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。

- 第四次挥手(ACK=1，ACKnum=y+1)

  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。

  服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。

  客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime，inux里一个MSL为30s）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。
  
  可靠安全的关闭TCP连接。比如网络拥塞，主动方最后一个ACK被动方没收到，这时被动方会重传FIN，发送多个FIN包，在这时尚未关闭的TIME_WAIT就会把这些尾巴问题处理掉，不至于对新连接及其它服务产生影响

四次挥手的示意图如下：
![](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png)

1. **如果机器出现大量连接处于CLOSE_WAIT怎样分析？**

   [close wait浅析](https://blog.huoding.com/2016/01/19/488)
   [close wait实例分析](https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&mid=402163560&idx=1&sn=5269044286ce1d142cca1b5fed3efab1&3rd=MzA3MDU4NTYzMw==&scene=6#rd)

2. **如果本端处于FIN_WAIT_2，但对端不发送FIN，会怎样？**

   Linux下当一个socket不再被任何应用引用时，它便成为了一个孤儿，而 tcp_fin_timeout 限定了成为孤儿的 FIN_WAIT2 所能存活的时间，实际上此时间是「net.ipv4.tcp_fin_timeout」控制的，不过在测试中发现，FIN_WAIT2 存在的时间并不是精确的等于 tcp_fin_timeout 的设置，存在一定的偏差。此外，需要说明的是在 tcp_fin_timeout 后，FIN_WAIT2 并没有迁移到 TIME_WAIT，而是直接关闭了

   如果是用shutdown关闭本端，此时FIN_WAIT2就不会成为孤儿，就不会受 tcp_fin_timeout限制，FIN_WAIT2 会一直存在，直到本端 close 连接或者进程退出

3. **如果本端处于LAST_ACK，但对端不发送ACK，会怎样？**

   `LAST_ACK` 状态也有超时机制，最后还是会到CLOSE状态

4. **为什么需要四次挥手？**

   TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化

   总的来说，需要正常结束双工通道就需要四次，两端在结束本端的发送工作都需要一对FIN和ACK，所以是四次
   
### 0.3 总结

1. **TCP连接过程是状态的转换，促使发生状态转换的是用户调用**

2. **三次握手和对应的用户调用：**
   1. 服务器通过socket()、bind()和listen()来完成CLOSED状态到LISTEN状态的转化，称为被动打开。被动打开完成之后，accept()阻塞，等待客户请求
   2. 客户端通过connect()进行主动打开。向服务端发送一个SYN分节，用于通知服务器客户端将在连接中发送数据的初始序列号（一般SYN分节不包含任何数据，只有TCP和IP的头部信息）
   3. 服务器以单个分节（ACK+SYN），同时对客户的SYN序列号进行确认，并发送自己的SYN序列号（此时accept()还在阻塞中）
   4. 客户端对服务器的SYN数据进行确认。客户端在收到服务器SYN并进行确认之后，connect()返回
   5. 服务器收到客户的确认端，accept()返回
   
3. **三次握手可能出现的异常：**
  
   1. 第一次握手丢包，默认情况下，connect()是阻塞式的，如果请求无法发送到服务器，那么connect会进行一段很长时间的等待和重试（重传次数和时间间隔暂且不去深究），此时可以使用通过设置SO_SNDTIMEO来为connect设置超时以减少connect的等待时间
   
   2. 第二次握手丢包，对于客户端来说，依然是connect超时，所以处理方式和第一次握手丢包是一样的。对于服务器来说，由于收不到第三次握手请求，所以会进行等待重传，直到多次重传失败后，关闭半连接
      - 服务器会维护一个syns queue，用于等待客户的第三次握手请求。当收到第三次握手请求，会将连接移到accept queue；多次重传失败后，服务器会将该半连接从syns queue中删除
      - 我们经常听说的DDos攻击，就可以在这个环节实现，syn flood就是一种常见的DDos攻击方式。简单来说，syn flood就是只发送第一次握手请求后，就关闭连接，将服务器的syns queue占满，从而让正常用户无法得到服务
      
   3. 第三次握手丢包，由于客户端在发送第三次握手包后，不再等待确认，就直接进入了ESTABLISHED状态，所以一旦第三次握手失败，客户端和服务器的状态就不同步了。当然，此时服务器会进行多次重发，一旦客户再次收到SYN+ACK（第二次握手请求），会再次确认。不过，如果第三次握手一直失败，则会出现，客户已经建立连接，而服务器关闭连接的情况。随后，一旦客户向服务器发送数据，则会收到一条RST回应，告诉用户连接已经重置，需要重新进行三次握手
   
      - **RST和SIGPIPE**：有过网络编程经验的人都知道在写网络通信的时候，需要屏蔽SIGPIPE信号，否则的话，一旦收到PIPE信号会导致程序异常退出。其实这个SIGPIPE就是由于write()的时候，我们自己的状态是ESTABLISHED而对方的状态不是ESTABLISHED，那么对方就会给我们一个RST回应，收到这个RST之后，系统就会自动生成一个PIPE信号
   
4. **四次挥手和对应的用户调用：**
   1. 客户端调用close()执行主动关闭，向服务端发送FIN，表示本端不再发送数据
   2. 服务端收到FIN进行被动关闭，由系统网络协议栈自动对FIN进行确认(发送ACK)。FIN作为文件结束符，传递给recv()，recv()返回0
   3. 在服务端发送完本端所有数据后，服务端调用close()关闭socket，发送FIN给客户端，表示本端不再发送数据
   4. 客户端收到FIN后，进入TIME_WAIT，向对端发送ACK，同时最多等待2MSL关闭socket
   
5. **四次挥手可能出现的异常：**

   1. 第一次挥手丢包，FIN_WAIT1丢失会导致客户端重传，如果多次重传失败，则客户端超时关闭连接，而服务器依然保持ESTABLISHED状态。如果**服务器主动发送数据**，则会收到一个RST包，重置连接。设置KeepAlive道理相同，**核心是要求服务器主动发数据**。如果服务器永远不会主动发数据，那么就会一直保持这样一个“假连接”
   2. 第二次挥手丢包，由于服务器第二次挥手（服务端发送的ACK）不会重发，所以即使丢包也不管，在服务端调用close()后会直接向对端发送FIN，此时客户端执行”**同时关闭**“的流程，进入TIME_WAIT状态，等待2MSL时间后关闭。在客户端进入TIME_WAIT之后，服务端由于发送FIN没有得到ACK，会重发FIN给客户端，如果被客户端TIME_WAIT收到并发送LAST-ACK，则流程正常结束；如果服务端反复重发FIN没有响应，那么服务端超时关闭（这种就是第四次挥手丢包的情况）
   3. 第三次挥手丢包，服务器会持续等待在LAST_ACK状态，而客户端会持续等待在FIN_WAIT2状态，最后双方超时关闭
   4. 第四次挥手丢包，客户端进入TIME_WAIT状态，等待2MSL，服务器由于收不到LAST-ACK则进行重发，如果多次重发失败，则服务端连接超时关闭

## 参考文献

- UNP第三版
- [笔试面试知识整理](https://hit-alibaba.github.io/interview/)
- [tcp十一种状态及问题处理方法](https://blog.csdn.net/bzfys/article/details/73733917)
- [TCP为什么需要3次握手与4次挥手](https://blog.csdn.net/xifeijian/article/details/12777187)
- [几种TCP连接中出现RST的情况](https://my.oschina.net/costaxu/blog/127394)
- [TCP/IP协议中backlog参数](https://www.cnblogs.com/Orgliny/p/5780796.html)
- [TCP协议RST：RST介绍、什么时候发送RST包](https://blog.csdn.net/guowenyan001/article/details/11766929)

