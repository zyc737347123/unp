# TCP/UDP/IP学习笔记

## UDP概览

### 1.0 UNP基本编程框架

UDP（user datagram protocol）的中文叫用户数据报协议，属于传输层协议。UDP是面向非连接的协议，它不与对方建立连接，而是直接把本端要发的数据报发给对方。所以UDP适用于一次传输数据量很少、对可靠性要求不高的或对实时性要求高的应用场景。正因为UDP无需建立类如三次握手的连接，而使得通信效率很高。

UDP的应用非常广泛，比如一些知名的应用层协议（SNMP、DNS）都是基于UDP的，想一想，如果SNMP使用的是TCP的话，每次查询请求都得进行三次握手，这个花费的时间估计是使用者不能忍受的，因为这会产生明显的卡顿。所以UDP就是SNMP的一个很好的选择了，要是查询过程发生丢包错包也没关系的，我们再发起一个查询就好了，因为丢包的情况不多，这样总比每次查询都卡顿一下更容易让人接受吧。

UDP通信的流程比较简单，因此要搭建这么一个常用的UDP通信框架也是比较简单的。以下是UDP的框架图
![](https://images2015.cnblogs.com/blog/1093303/201701/1093303-20170115195937619-2089905370.jpg)

由上图可以看出，客户端要发起一次请求，仅仅需要两个步骤（socket和sendto），而服务器端也仅仅需要三个步骤即可接收到来自客户端的消息（socket、bind、recvfrom）

### 1.1 UDP的bind()

UDP的bind函数和TCP 的bind函数的作用是一致的，就是为socket绑定本端的端口和地址信息，所以服务端必须调用bind()，否则客户端无法发送数据到服务端。客户端可以不调用bind()，udp在创建套接字后直接使用sendto()，隐含操作是在发送数据之前操作系统会为该套接字随机分配一个合适的udp端口，将该套接字和本地地址和端口号进行绑定

### 1.2 UDP的connect()

UDP的connect函数只是为socket绑定目的地址和目的端口，UDP客户端可以在发送数据前，先调用connect()指明目的地址和目的端口，后续就可以使用send()进行数据发送，同时可以使用recv接受已绑定的目的地址的数据。需要注意，当一个UDP socket进行connect后，sendto()中的地址参数会被忽略，**所以服务端的UDP socket不能使用connect()**

**UDP的connect没有三次握手，仅仅是维护了一个信息，一个套接字状态，仅仅用于表示确定了对端的地址，没有其他含义**，因此已连接的UDP socket可以使用send、recv。

**本端的UDP socket的IP和端口是否会在第一次连接后固定下来，直到该socket close()?**

从上面可以知道UDP socket分两种

1. 未连接的UDP socket
2. 已连接的UDP socket

对于未连接的套接字，也就是我们常用的的UDP套接字，我们使用的是sendto/recvfrom进行信息的收发，目标主机的IP和端口是在调用sendto/recvfrom时确定的，在一个未连接的UDP套接字上给两个数据报调用sendto函数内核将执行以下六个步骤：

1. 连接套接字（**内核分配内存记录对端地址信息**）
2. 输出第一个数据报
3. 断开套接字连接（**内核释放记录的对端地址信息**）
4. 连接套接字（如上）
5. 输出第二个数据报
6. 断开套接字连接（如上）

对于已连接的UDP套接字，必须先经过connect来对目标服务器进行指定，然后调用read/write进行信息的收发，目标主机的IP和端口是在connect时确定的，也就是说，一旦conenct成功，我们就只能对该主机进行收发信息了

已连接的UDP套接字给两个数据报调用write函数内核将执行以下三个步骤：

1. 连接套接字

2. 输出第一个数据报

3. 输出第二个数据报

由此可以知道，当使用UDP协议需要给同一个目的地址的端口号发送多个数据报时，已连接的UDP socket效率更高。**并且只有已连接的socket才能收到ICMP应答错误**，比如服务端没有打开时，客户端发送数据就会产生ICMP应答错误，如果是未连接的UDP socket就不会收到这个ICMP应答错误。

### 1.3 UDP的连接性和负载均衡

[UDP：连接性和负载均衡](https://cloud.tencent.com/developer/article/1004555)

上面提到服务端UDP socket不能使用connect()，会导致该socket只能向一台机器发送数据，但也有例外。为了更好的利用多核CPU服务器，结合两个socket选项可以令UDP服务端也做到一个socket对应一个客户端连接。详情看上文

### 1.4 UDP的疑难杂症

[UDP：疑难杂症和使用](https://cloud.tencent.com/developer/article/1004554)

### 1.5 TCP和UDP的区别

1. **TCP是面向连接的，UDP是面向无连接**

   **所谓建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。TCP是一个有状态服务，TCP状态机记录着整个通信过程（数据的发送情况，网络的拥塞情况，两端的连接情况等等）**

2. **TCP是面向字节流的，UDP是面向报文的**

   - **UDP的通信有界性**

     **在阻塞模式下，UDP的通信是以数据包作为界限的**，即使server端的缓冲区再大也要按照client发包的次数来多次接收数据包，server只能一次一次的接收，client发送多少次，server就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收

   - **UDP数据包的无序性和非可靠性**

     client依次发送1、2、3三个UDP数据包，server端先后调用3次接收函数，可能会依次收到3、2、1次序的数据包，收包可能是1、2、3的任意排列组合，也可能丢失一个或多个数据包

   - **UDP数据包的接收**

     client发送两次UDP数据，第一次 500字节，第二次300字节，server端阻塞模式下接包，第一次recvfrom( 1000 )，收到是 1000，还是500，还是300，还是其他？

     - 由于UDP通信的有界性，接收到只能是500或300，又由于UDP的无序性和非可靠性，接收到可能是300，也可能是500，也可能一直阻塞在recvfrom调用上，直到超时返回(也就是什么也收不到)。

     在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，server端阻塞模式下接包，先后三次调用：recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，接收情况如何呢？

     - 由于UDP通信的有界性，第一次recvfrom( 200)将接收第一个500字节的数据包，但是因为用户空间buf只有200字节，于是只会返回前面200字节，剩下300字节将丢弃。第二次recvfrom( 1000)将返回300字节，第三次recvfrom( 1000)将会阻塞。

   - **UDP包分片问题**

     如果MTU是1500，Client发送一个8000字节大小的UDP包，那么Server端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到1500，还是8000。如果某个IP分片丢失了，recvfrom(9000)，又返回什么呢？
     根据UDP通信的有界性，在接收端缓冲区足够大的情况下，接收到的一定是一个完整的数据包，UDP数据在下层的分片和组片问题由IP层来处理，提交到UDP传输层一定是一个完整的UDP包，那么recvfrom(9000)将返回8000。如果某个IP分片丢失，udp里有个CRC检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以UDP是不可靠的传输协议，那么recvfrom(9000)将阻塞。

3. **TCP的可靠交付和拥塞控制和流量控制**

   **这些都是TCP特有的，基本原因还是UDP是一个无状态服务**

### 参考文献

- 极客时间<趣谈网络协议>
- [Linux编程之UDP SOCKET全攻略](https://www.cnblogs.com/skyfsm/p/6287787.html)
- [基本UDP编程细节](https://blog.csdn.net/NK_test/article/details/49431199)
- [udp通讯中的connect()和bind()函数](https://blog.csdn.net/qq_29344757/article/details/71616748)
- [UDP：连接性和负载均衡](https://cloud.tencent.com/developer/article/1004555)
- [UDP：疑难杂症和使用](https://cloud.tencent.com/developer/article/1004554)